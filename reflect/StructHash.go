package reflect

import (
	"fmt"
	"reflect"

	"github.com/barbell-math/util/hash"
	"github.com/barbell-math/util/iter"
	"github.com/barbell-math/util/widgets"
)

//go:generate ../bin/enum -type=optionsFlag -package=reflect
//go:generate ../bin/flags -type=optionsFlag -package=reflect
//go:generate ../bin/structDefaultInit -struct=structHashOpts

type (
	//gen:enum unknownValue unknownOptionsFlag
	//gen:enum default includeMapVals | includeArrayVals | includeSliceVals | followPntrs
	optionsFlag    int
	structHashOpts struct {
		optionsFlag `default:"NewOptionsFlag()" setter:"f" getter:"f"`
	}
)

const (
	// Description: set to true if the hash value should be calculated by
	// following pointer values rather than using the pointers value itself
	//
	// Used by: [ToStructs]
	//
	// Default: true
	//gen:enum string followPntrs
	followPntrs optionsFlag = 1 << iota
	// Description: set to true if the hash value should be calculated by
	// following interface values rather than using the interface value itself
	//
	// Used by: [ToStructs]
	//
	// Default: true
	//gen:enum string followInterface
	followInterface
	// Description: set to true to include map key value pairs in the hash
	// calculation
	//
	// Used by: [ToStructs]
	//
	// Default: true
	//gen:enum string includeMapVals
	includeMapVals
	// Description: set to true to include slice values in the hash calculation
	//
	// Used by: [ToStructs]
	//
	// Default: true
	//gen:enum string includeSliceVals
	includeSliceVals
	// Description: set to true to include array values in the hash
	// calculation
	//
	// Used by: [ToStructs]
	//
	// Default: true
	//gen:enum string includeArrayVals
	includeArrayVals
	//gen:flags noSetter
	//gen:enum string unknownOptionsFlag
	unknownOptionsFlag
)

func typeCastHashOp[
	T any,
	W widgets.BaseInterface[T],
](val ValInfo, h *hash.Hash) {
	w := widgets.Base[T, W]{}
	if !val.v.Type().AssignableTo(reflect.TypeOf((*T)(nil)).Elem()) {
		return
	}
	if iterV, err := val.Pntr(); err == nil {
		*h = h.Combine(w.Hash(iterV.(*T)))
	}
}

func pointerHashOp(val ValInfo, h *hash.Hash) {
	w := widgets.BuiltinUintptr{}
	if val.v.CanAddr() {
		v := uintptr(val.v.Addr().Pointer())
		*h = h.Combine(w.Hash(&v))
	}
}

func getHash(val ValInfo, opts *structHashOpts) hash.Hash {
	var rv hash.Hash
	switch val.Kind {
	case reflect.Bool:
		typeCastHashOp[bool, widgets.BuiltinBool](val, &rv)
	case reflect.Int:
		typeCastHashOp[int, widgets.BuiltinInt](val, &rv)
	case reflect.Int8:
		typeCastHashOp[int8, widgets.BuiltinInt8](val, &rv)
	case reflect.Int16:
		typeCastHashOp[int16, widgets.BuiltinInt16](val, &rv)
	case reflect.Int32:
		typeCastHashOp[int32, widgets.BuiltinInt32](val, &rv)
	case reflect.Int64:
		typeCastHashOp[int64, widgets.BuiltinInt64](val, &rv)
	case reflect.Uint:
		typeCastHashOp[uint, widgets.BuiltinUint](val, &rv)
	case reflect.Uint8:
		typeCastHashOp[uint8, widgets.BuiltinUint8](val, &rv)
	case reflect.Uint16:
		typeCastHashOp[uint16, widgets.BuiltinUint16](val, &rv)
	case reflect.Uint32:
		typeCastHashOp[uint32, widgets.BuiltinUint32](val, &rv)
	case reflect.Uint64:
		typeCastHashOp[uint64, widgets.BuiltinUint64](val, &rv)
	case reflect.Float32:
		typeCastHashOp[float32, widgets.BuiltinFloat32](val, &rv)
	case reflect.Float64:
		typeCastHashOp[float64, widgets.BuiltinFloat64](val, &rv)
	case reflect.Complex64:
		typeCastHashOp[complex64, widgets.BuiltinComplex64](val, &rv)
	case reflect.Complex128:
		typeCastHashOp[complex128, widgets.BuiltinComplex128](val, &rv)
	case reflect.String:
		typeCastHashOp[string, widgets.BuiltinString](val, &rv)
	case reflect.Uintptr:
		typeCastHashOp[uintptr, widgets.BuiltinUintptr](val, &rv)
	case reflect.Pointer:
		if opts.GetFlag(followPntrs) {
			fmt.Println(val)
			rv = rv.Combine(getHash(
				NewValInfo(val.v.Elem(), false, nil),
				opts,
			))
		} else {
			pointerHashOp(val, &rv)
		}
	case reflect.Chan:
		pointerHashOp(val, &rv)
	case reflect.Array:
		if opts.GetFlag(includeArrayVals) {
			// TODO - iterate over array and get hash values
		} else {
			pointerHashOp(val, &rv)
		}
	case reflect.Slice:
		if opts.GetFlag(includeArrayVals) {
			// TODO - iterate over slice and get hash values
		} else {
			pointerHashOp(val, &rv)
		}
	case reflect.Map:
		if opts.GetFlag(includeMapVals) {
			// TODO - iterate over map and get hash values
		} else {
			pointerHashOp(val, &rv)
		}
	case reflect.Func:
		pointerHashOp(val, &rv)
	case reflect.Interface:
		if opts.GetFlag(followInterface) {
			// TODO - follow interface data value
		} else {
			pointerHashOp(val, &rv)
		}
	case reflect.Struct:
		fallthrough // iteration will be handled by the calling func
	case reflect.UnsafePointer:
		fallthrough // do nothing because it's unsafe
	case reflect.Invalid:
		fallthrough // Ignore "bad" values
	default:
	}
	return rv
}

// Returns a hash for the supplied struct. The hash is generated by reflexively
// iterating over exported structs fields. There are a couple rules that dictate
// the hash value that is generated:
//
//  1. The widgets in the [widgets] package are used for generating hashes when
// the underlying type is an exact match. Custom types of the built in types
// will not have a hash value generated.
//  2. Only exported fields are exported. A struct with no exported fields will
// have a hash of 0.

// The opts struct determines behaviors about which struct fields are used and
// how they are used. 
func StructHash[T any, S reflect.Value | *T](
	s S,
	opts *structHashOpts,
) (hash.Hash, error) {
	var rv hash.Hash
	err:=RecursiveStructFieldInfo[T, S](s, false).ForEach(
		func(index int, val FieldInfo) (iter.IteratorFeedback, error) {
			rv=rv.Combine(getHash(val.ValInfo, opts))
			return iter.Continue, nil
		},
	)
	return rv, err
}
